---
layout: page
title: Creating a package in Julia
permalink: /posts/buildsystems/julia_pkg
exclude: true
referenceId: julia_pkg
---

<div>
{% include enable_image_zoom.html %}
</div>

<div>
{% include smart_link/load_url_file.html url_file=site.data.external_urls_buildsystems_julia %}
</div>

<div>
{% include enable_title_numbering.html %}
</div>

<warning-box>
In this article, we will be programming in Julia. The Julia programming language and the associated ecosystem are still actively being developed, and as such, the APIs may change over time. In this article, we are working with Julia v1.11. Version numbers for the packages used are also included in this article.
</warning-box>

## Introduction

The Julia programming language is a programming language that focuses on scientific programming.
The advantages of Julia are that it is flexible and easy to use, while also providing excellent performance. Another key strength is its large scientific ecosystem: many useful tools for physics, engineering, and other sciences, are publicly available as packages. This article explains how to set up a basic package structure for a Julia project.

In what follows, we will build a small library that can construct polynomials based on a list of coefficients, and which can then be used to compute and plot the derivatives of such polynomials. Afterwards, we will use this library in a command-line application as well as in a Pluto notebook. The library will be implemented as a package, including dependencies and unit tests.

This article assumes that Julia is already installed. Information about installing Julia can be found in <smart-link linkType="ext" linkId="julia_installation">the installation instructions</smart-link>. This tutorial was made to work on MacOS.

## Overview

<tableOfContents></tableOfContents>

## Creating a project

In order to create a new project, we open a terminal and navigate to the desired location of the project. We then run the following command:
```
julia -e 'using Pkg; Pkg.generate("FunctionDiff");'
```

What this command does is invoke the `julia` executable and tell Julia we wish to execute some code (`-e`) with the last argument specifying the code we wish to run. This will then create a project called `FunctionDiff`. We can now see the following file structure in the working directory:

```
.
+-- FunctionDiff
    +-- src
    |   +-- FunctionDiff.jl
    +-- Project.toml
```

The `Project.toml` file is important when managing our Julia project. If we open the file, we can see that Pkg has created some basic contents for this file:
```toml
name = "FunctionDiff"
uuid = "876653dc-bc1b-485c-95c5-59d65e9ef9e7"
authors = ["AUTHOR INFORMATION"]
version = "0.1.0"
```

The other file, `src/FunctionDiff.jl`, will contain the functionality of our package. Currently, it consists of some placeholder code generated by Pkg:
```julia
module FunctionDiff

greet() = print("Hello World!")

end # module FunctionDiff
```

We can also run the placeholder code from the command-line:
```
julia --project=./FunctionDiff -e "import FunctionDiff; FunctionDiff.greet();"
```

The above command tells Julia to activate the local environment (`--project=./FunctionDiff`), to import our module, and to run the `greet()` function.

If everything is in order, we should see the following output in the terminal:
```
Hello world!
```

## Dependencies

As stated in the introduction, our goal is to build a small library that can construct and derive polynomials, as well as plot them. To this end, we will use the Polynomials.jl package for the mathematical operations, and the Plots.jl package to draw function plots.

Installing packages in Julia is very easy. We first open the Julia REPL by running `julia --project=./FunctionDiff`. We then press `]` to open the Pkg mode. Packages can then be added with the `add` command:
```
add Plots
add Polynomials
```

After running these commands, the following section should be present in `Project.toml`:
```toml
[deps]
Plots = "91a5bcdd-55d7-5caf-9e0b-520d859cae80"
Polynomials = "f27b6e38-b328-58d1-80ce-0feddd5e7a45"
```

There is, of course, the question of compatibility. Good software engineering practices require us not only to state which packages we need, but also the desired version of the packages. Providing these version numbers allows our program to be <em>reproducible</em>, such that running the program always gives the same results on any system.

To do this, we run the `compat` command while in Pkg mode:
```
compat
```

This will present us with an interactive command-line interface that asks us which versions we need for which package. For Plots.jl we will use version 1.40.8, with version string `=1.40.8`. We will do the same for Polynomials.jl version 4.0.11.

After running these commands, the following section should be present in `Project.toml`:
```toml
[compat]
Plots = "=1.40.8"
Polynomials = "=4.0.11"
```
Note that it is also possible to add packages and specify version numbers by manually editing the `Project.toml` file. Finally, there exists a specific syntax for version numbers, the full explanation can be found in <smart-link linkType="ext" linkId="julia_version_format">the documentation on compatibility</smart-link>.

## Creating our library

The functionalities of our library will be implemented in the `FunctionDiff.jl` file of the `src` directory. We remove the `greet()` function and end up with an empty module:

```julia
module FunctionDiff

end
```

In the following sections we will be adding the necessary functionalities one by one.

### Polynomials and derivatives

For constructing and deriving polynomials, the Polynomials.jl package offers all the necessary functionalities. We will first add a function to construct polynomials:

```julia
"""
    getPolynomial(coeffs::Array{Float64})

Construct a polynomial from the specified coefficients. The coefficients are
ordered from low to high degree.
"""
function getPolynomial(coeffs::Array{Float64})
    return Polynomial(coeffs)
end
```

We do something similar for computing the derivative, by accepting a `Polynomial` object and passing it to the `derivative` function of the Polynomials.jl package:

```julia
"""
    getDerivative(polynomial::Polynomial)

Take the derivative of the specified polynomial.
"""
function getDerivative(polynomial::Polynomial)
    return derivative(polynomial)
end
```

Aside from computing the derivative, we also wish the obtain the higher-order derivatives. For this, we simply repeatedly take the derivative. 

```julia
"""
    getHigherDerivative(polynomial::Polynomial, order::Int)

Take the n-th order derivative of the specified polynomial.
"""
function getHigherDerivative(polynomial::Polynomial, order::Int)
    higher_derivative = polynomial
    for i in 0:order-1
        higher_derivative = getDerivative(higher_derivative)
    end
    return higher_derivative
end
```

We can try out our code by navigating to our project directory in the terminal and opening the Julia REPL:

```
julia --project=./FunctionDiff
```

In order to obtain a polynomial, we first import our `FunctionDiff` library, and we call the `getPolynomial` function. Julia will then report the created polynomial $f(x) = 3x^2 + 2x + 1$.

```
julia> using FunctionDiff
julia> polynom = FunctionDiff.getPolynomial([1.0,2.0,3.0])
Polynomial(1.0 + 2.0*x + 3.0*x^2)
```

We can then derive this polynomial using the `getDerivative` command. We can see that the derivative $f'(x) = 6x + 2$ has been computed.
```
julia> deriv = FunctionDiff.getDerivative(polynom)
Polynomial(2.0 + 6.0*x)
```

Similarly, we can use `getHigherDerivative` to compute the 2nd derivative, which is $f''(x) = 6$.

```
julia> deriv2 = FunctionDiff.getHigherDerivative(polynom, 2)
Polynomial(6.0)
```

### Plots

In order visualise the effect of deriving polynomials, we will add plotting functionality to our package. This will take a polynomial and a derivative and plot them both for values $x \in [-3,3]$. We return the plot, such that people who use our library can then modify it further or save it to a file.

```julia
"""
    plotFunction(f::Polynomial, derivative::Polynomial)

This function will plot the specified polynomial and its derivative on the 
domain x \\in [-3.0, 3.0]. The image is restricted to y \\in [-3.0, 3.0].

The plot object will be returned.
"""
function plotFunction(polynom::Polynomial, derivative::Polynomial)
    # compute values
    x = range(-3.0, 3.0, length=100)
    func_values = polynom.(x)
    deriv_values = derivative.(x)

    # plot values
    pl = plot(x, [func_values, deriv_values], title="Function and derivative", 
              label=["f(x)" "derivative"], dpi=500)
    ylims!(-3.0, 3.0)
    
    return pl
end
```

If we open the Julia REPL using `julia --project=./FunctionDiff`, we can play around with the plotting functionality. As a demonstration, we will create a polynomial and plot it together with its derivative.

```
julia> using FunctionDiff
julia> polynom = FunctionDiff.getPolynomial([-0.5, -1.8, -1.7, 1.4, 1.3])
julia> deriv = FunctionDiff.getDerivative(polynom)
julia> FunctionDiff.plotFunction(polynom, deriv)
```

In the resulting plot we can see both the function and the derivative. Also note that the Plots.jl package has added axes, colouring, and a legend.

<div class="fig-row">
    <div class="fig-in-row">
        <figure>
            <figureImage imgSrc="/assets/images/buildsystems/julia_plot.png"></figureImage>
            <figcaption>Plot.</figcaption>
        </figure>
    </div>
</div>

### Unit tests

The Julia language also offers unit-testing facilities. The standard way to add unit-tests to a project is by adding a `test` directory to our project. In this directory we will create two files `Project.toml` and `runtests.jl`:

```
.
+-- FunctionDiff
    +-- src
    |   +-- FunctionDiff.jl
    +-- test
    |   +-- Project.toml
    |   +-- runtests.jl  
    +-- Project.toml
```

In `Project.toml` we will add dependencies that are needed during our tests, but not when using our library. This is similar to the `testImplementation` configuration in Gradle. The `runtests.jl` file will be the entry point for running our tests, similar to a "main file". 

Note that the dependencies of the project are not always available in the test environment. For our tests, we will need the Polynomials.jl package. We can add this by first opening the Julia REPL in our test directory using the command `julia --project=./FunctionDiff/test`, after which we open Pkg-mode and do `add Polynomials`. We will also add the `Test` package, which provides useful unit-testing facilities.

In Julia, tests are grouped in test sets. Each test set can contain tests, or other test sets. We will begin by adding a test set `FunctionDiffTest` to `runtests.jl`:

```julia
using FunctionDiff
using Polynomials
using Test

@testset "FunctionDiffTests" begin
    # ...
end
```

We will add three test sets: one for constructing polynomials, one for taking the derivative, and one test set for taking higher order derivatives. We will assume the plotting functionality works as intended and not provide any unit tests for it.

```julia
using FunctionDiff
using Polynomials
using Test

@testset "FunctionDiffTests" begin
    @testset "getPolynomialTest" begin
        # ...
    end

    @testset "getDerivativeTest" begin
        # ...
    end

    @testset "getHigherDerivativeTest" begin
        # ...
    end
end
```

Next, we will add the actual tests and asserts. For this, we will construct polynomials and take derivatives, and then compare the result to the expected `Polynomial` object.

```julia
using FunctionDiff
using Polynomials
using Test

@testset "FunctionDiffTests" begin
    @testset "getPolynomialTest" begin
        @test FunctionDiff.getPolynomial([-6.3344, 1.0, 2.0, -3.45, 4.0]) == Polynomial([-6.3344, 1.0, 2.0, -3.45, 4.0])
    end

    @testset "getDerivativeTest" begin
        @test FunctionDiff.getDerivative(Polynomial([1.0, 2.0, 3.0, 4.0])) == Polynomial([2.0, 6.0, 12.0])
    end

    @testset "getHigherDerivativeTest" begin
        @test FunctionDiff.getHigherDerivative(Polynomial([0, 3.0, 2.0, -6.0]), 1) == Polynomial([3.0, 4.0, -18.0])
        @test FunctionDiff.getHigherDerivative(Polynomial([0, 3.0, 2.0, -6.0]), 2) == Polynomial([4.0, -36.0])
        @test FunctionDiff.getHigherDerivative(Polynomial([0, 3.0, 2.0, -6.0]), 3) == Polynomial([-36.0])
    end
end
```


We can invoke our tests with the following terminal command:

```
julia --project=./FunctionDiff ./FunctionDiff/test/runtests.jl
```

If all is well, Julia should report that all tests passed:

```
Test Summary:     | Pass  Total  Time
FunctionDiffTests |    5      5  0.2s
```

Note that the tests can also be run by opening the Pkg mode and invoking the `test` command.

## Using your package

Now that we have fully developed a library for constructing, deriving, and plotting polynomials, we would like to actually make use of this FunctionDiff.jl package. In Julia it is possible to use your own packages on your local computer.

### Developing a package

We will begin by using our package on our own local computer. To do this, we will install our package by <em>developing</em> it.

In order to do this, we will first open the Julia REPL and then we open Pkg mode. Make sure that the FunctionDiff.jl project is not the active project! We then run the command `develop ./FunctionDiff`, which will install our FunctionDiff.jl project into the default environment.

If you no longer want to have this package installed, you can open Pkg mode and activate the default environment. Then you can just do `remove FunctionDiff`. You can also view all installed packages by running the `status` command in Pkg mode.

### Adding a command-line interface

The next step is creating a Julia script that provides access to the functionalities of our FunctionDiff.jl package through a command-line interface.

We begin by creating a new folder somewhere outside of our package, called `polynom_tool`. We will create a new project here, and install a single dependency `ArgParse`:
- open the Julia REPL: `julia --project=./polynom_tool`,
- open Pkg mode,
- install ArgParse: `add ArgParse`.

We then create a new file `run_program.jl` in the `polynom_tool` directory, which will contain our `main` function and everything that has to do with the command-line interface of our program.

Adding a `main` function is easy, we simply add the following to the `run_program.jl` file:
```julia
"""
   Run the program.
"""
function main()
    println("Hello world!")
end

# check that we are running the script and not importing it
if abspath(PROGRAM_FILE) == @__FILE__
    main()
end
```

The if-statement makes sure that the `main()` function is only called if we run the script and not when we include it. This is similar to using `if __name__ == "__main__"` in Python.

We can run this main file using the command `julia --project=./polynom_tool ./polynom_tool/run_program.jl`.

```
Hello world!
```

Next, we will make a function `parse_commandline()` that parses command-line arguments. The user will have to supply three arguments:
- `coeffs`: the coefficients of the polynomial,
- `order`: the order of derivation, optional,
- `plot`: the filename of the saved plot, optional.

```julia
"""
    parse_commandline()

Parse the command-line arguments passed to the program.

This will return a `Dict` with the following keys:
- `coeffs` an `Array{Float64}` with the coefficients, low order to higher order,
- `order` an optional integer with the order of the derivative,
- `plot` an optional string with the filename of the plot.
"""
function parse_commandline()
    settings = ArgParseSettings()

    @add_arg_table! settings begin
        "--coeffs"
            nargs = '+'  # at least one argument, maybe more
            arg_type = Float64
            required = true
        "--order"
            arg_type = Int
            default = 1  # optional with default value
        "--plot"
            arg_type = String
            default = nothing  # optional with no default value

    end

    return parse_args(settings)
end
```

We can print out all passed arguments by modifying our `main` function:

```julia
"""
   Run the program.
"""
function main()
    println("Hello world!")
    println(parsed_args)
end
```

If we now pass some arguments via the command-line, the result will be printed:

```
julia --project=./FunctionDiff ./polynom_tool/run_program.jl --coeffs 1 2 3 --order 5 --plot "hello.png"
Dict{String, Any}("plot" => "hello.png", "order" => 5, "coeffs" => [1.0, 2.0, 3.0])
```

Now that we have all our arguments, we can use them to call our FunctionDiff.jl package. We first add `using FunctionDiff` and `using Plots` to the top of our `run_program.jl`. We then also modify the `main` function:

```julia
"""
   Run the program.
"""
function main()
    parsed_args = parse_commandline()

    coeffs = parsed_args["coeffs"]
    order = parsed_args["order"]

    polynom = FunctionDiff.getPolynomial(coeffs)
    higher_deriv = FunctionDiff.getHigherDerivative(polynom, order)

    println("Function: ", polynom)
    println("Order $order derivative: ", higher_deriv)

    filename = parsed_args["plot"]
    if !isnothing(filename)
        println("Plotting to '$filename' ...")
        pl = FunctionDiff.plotFunction(polynom, higher_deriv)
        savefig(pl, filename)
    end
end
```

We can now run our program with the following command

```
julia --project=./FunctionDiff ./polynom_tool/run_program.jl --coeffs -0.5 -1.8 -1.7 1.4 1.3 --order 1 --plot "plot.png"
```

Our command-line program will then report the polynomial and its derivative:

```
Function: -0.5 - 1.8*x - 1.7*x^2 + 1.4*x^3 + 1.3*x^4
Order 1 derivative: -1.8 - 3.4*x + 4.2*x^2 + 5.2*x^3
```

A plot of the function will be saved to `plot.png`:
<div class="fig-row">
    <div class="fig-in-row">
        <figure>
            <figureImage imgSrc="/assets/images/buildsystems/julia_plot.png"></figureImage>
            <figcaption>Contents of <code>plot.png</code>.</figcaption>
        </figure>
    </div>
</div>

### Using our library in Pluto

Another way to make use of Julia packages, is to use them in a Pluto notebook. These are very similar to Jupyter notebooks for Python. We use Pluto v0.20.1.

To make use of Pluto we first need to start the Julia REPL. Pluto can be installed using `add Pluto` in Pkg mode. Once the package is installed, we can simply run the following code:

```julia
using Pluto
Pluto.run()
```

If all is well, a new browser window or tab will now open. To get started with a notebook, we can use one of the following three options:
1. create a new notebook using the button with the plus sign,
2. open one of the existing notebooks, by pressing a button with a "play" sign, or
3. download a notebook from a URL by filling in the  "Enter path or URL..." field.

<div class="fig-row">
    <div class="fig-in-row">
        <figure>
            <figureImage imgSrc="/assets/images/buildsystems/pluto_welcome_screen.png"></figureImage>
            <figcaption>The welcome screen.</figcaption>
        </figure>
    </div>
</div>

For the purpose of demonstration, we will create a new notebook. A Pluto notebook is divided into cells. Each cell can either contain code, or it can contain markdown text.

If we want to use our FunctionDiff.jl package that we installed locally, we first have to override the built-in package manager of Pluto with the code below. This code will activate the default environment, in which we installed our FunctionDiff.jl package. Pay attention to the `begin` and `end` keywords!
```julia
begin
    import Pkg
    Pkg.activate()
    using FunctionDiff
end
```

We will once again consider the example from earlier. We add the following three lines to separate cells in the notebook:

```julia
polynom = FunctionDiff.getPolynomial([-0.5, -1.8, -1.7, 1.4, 1.3])
deriv = FunctionDiff.getDerivative(polynom)
FunctionDiff.plotFunction(polynom, deriv)
```

Pluto will now report the polynomial and its derivative, and produce the following plot:

<div class="fig-row">
    <div class="fig-in-row">
        <figure>
            <figureImage imgSrc="/assets/images/buildsystems/julia_plot.png"></figureImage>
            <figcaption>Contents of the plot.</figcaption>
        </figure>
    </div>
</div>

The <smart-link linkType="ext" linkId="pluto_notebook_link">full notebook</smart-link> with some examples can be found on GitHub. You can try to open it in Pluto by passing the URL to the "Enter path or URL..." field on the welcome screen.

## More advanced topics

In the tutorial above, we have only touched upon the basic functionalities of the Julia programming language. In order to build real-world projects that are used by other people, other techniques will be necessary. We will briefly go over a few of them, below.


### Registering your package

We have seen how we can install our package locally using the `develop` command in Pkg. However, if we want other people to use our package, they will need to be able to automatically download and install it using the `add` command.

In order to do this, you will need to make your package available as a Git repository. Then, you can make a pull request to the JuliaRegistries GitHub repository, in order to have your package included in the registry. Once that is done, people will be able to easily download and install your package.

More information can be found on the <smart-link linkType="ext" linkId="julia_package_registry_git">JuliaRegistries GitHub repository</smart-link>.

### Contributing to projects on GitHub

You can also contribute to existing Julia projects. In order to do this, you will need to manually download the code of the package. This can be done, for example, by cloning a Git repository. Then, you will need to open the Julia REPL: `julia --project=./path/to/downloaded/project`. Next, open Pkg mode and use the following three commands:
- `activate .`: activate the environment of the downloaded project,
- `instantiate`: create the `Manifest.toml` file and install all dependencies,
- `test`: run all unit-tests to see if everything is in order.

After these steps, you can make changes to the code and push the contributions to the git repository.

### Installing packages from GitHub

You may want to install a package that is not available in the registry. This might also happen if you want to use the latest version of a package that has not yet been pushed to the registry. 

In that case, you once again manually download the code of the package. This time, however, navigate to the project and activate the Julia REPL. In Pkg mode, you can then run the `develop` command to install the package locally. Be careful to only install packages you trust!

### More advanced projects

More advanced projects will have their code stored in a Git repository. Aside from hosting your project and providing version control facilities, your Git provider might also provide support for *continuous integration* (CI). 

This means that every time you push changes to the repository, a few tools are automatically run. This can include unit-tests and style checks, but also book-keeping functionalities such as automatically registering new versions of your package, generating documentation, etc.

In order to set this up, it might be worthwhile to take a look at the <smart-link linkType="ext" linkId="pkg_templates_github">PkgTemplates.jl project</smart-link>. This tool allows you to create new projects, similar to `Pkg.generate()`, but it will also help with setting up CI, package registration, dependency management, documentation, test coverage, etc.

### Version numbering

For our FunctionDiff.jl project, we set the version number to 0.1.0. Additionally, we have also specified version numbers for dependencies, such as `"=1.40.8"`. In the Julia programming language, there is a specific syntax for version numbers, which helps Pkg to correctly determine which package version to install. More information can be found in <smart-link linkType="ext" linkId="julia_version_format">the documentation on version numbers</smart-link>.

### More advanced Julia language features

Up until now, we have only used functions, if-statements, variables, etc. The Julia programming language also provides more advanced features, however. Examples are structs, parametric types (similar to templates in C++), operator overloading, various numeric data types, etc.

## Conclusion

In this article we have explored the basics of the Julia programming language. We have created a library called FunctionDiff.jl that allows us to construct, derive, and plot polynomials. We also added a few unit-tests. We then used our library in a command-line application as well as in a Pluto notebook.

The code can be found on <smart-link linkType="ext" linkId="julia_tutorial_github_code">GitHub</smart-link>. You can also download the <smart-link linkType="ext" linkId="pluto_notebook_link">Pluto notebook</smart-link>.

As noted in the section on more advanced topics, there is a lot more to learn about Julia. The following resources can help:
- the official documentation,
- the Git repositories of various packages,
- package-specific documentation,
- questions and answers on Stackoverflow,
- talks and tutorials on YouTube.

In the future, I will be writing more articles that make use of the Julia programming language, so stay tuned!
